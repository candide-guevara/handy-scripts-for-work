#! /bin/bash
## Defines command alias and routines for tasks common to home and work

AWK_MAN_FORMAT="$MY_ROOT_SCRIPT/awk/manparser.awk"
TMP_HELP_FILE="$TEMP/help.autogenerated.tmp"

## *USAGE : mll [PATTERN] [EXTRA_FLAG]
## Like ls with long listing but PATTERN is case insensitive and
## matches any part of the file name
mll() {
  setoption nocaseglob
  [[ -z $pattern ]] || shift
  # Zsh does not perform file name expansion on variables and local forces expansion
  eval "ls $1 $pattern"
  setoption caseglob
}

# Some scripts in the office may break unless we do this
alias ls='ls --color=always -C'
if [[ "$IS_GOOGLE_MAC" == 1 ]]; then
  alias ls='ls -GC'
  alias ll='ls -lhG'
elif [[ ("$IS_HOME" == 1 && "$IS_BASH" == 1) || "$IS_MSYS" == 1 ]]; then
  alias ll='ls -l --group-directories-first --human-readable --time-style=iso --no-group'
elif [[ "$IS_GOOGLE_UNIX" == 1 || "$IS_UNIX" == 1 ]]; then
  alias ll='ls -l --color=always --human-readable --time-style=iso --no-group'
else
  alias ll='ls -lh'
fi

alias vi=vim
alias su='su --login'

alias lll='ll | less'
alias la='ll -A'
alias lla='ll -A | less'

alias menv='env | sort | grep -i'

alias ..='cd ..; ls'
alias .2='cd ..; cd ..; ls'
alias .3='cd ..; cd ..; cd ..; ls'

## *USAGE : mps PROCESS_PAT
## Looks for running processes matching PROCESS_PAT in their whole command line.
function mps() {
  local -a allpids=`pgrep -f "${1}"`
  ps -ef | grep -i "${1}"
  echo "${allpids[@]}" | to_space_separated
}

## *USAGE : list_cnx PROCESS_PAT
## Looks for running processes matching PROCESS_PAT and displays their network connections
list_cnx() {
  local allpids=`pgrep -f "${1}" | paste -s -d,`
  local oredpids=`echo "$allpids" | sed 's/,/|/g'`
  local message="All the following are equivalent :
    sudo lsof -p '$allpids' -a #-iTCP -sTCP:LISTEN
    sudo netstat -anp --tcp | grep -E '$oredpids'
    sudo ss -anpe --tcp | grep -E '$oredpids'
  "
  colecho $txtcyn "$message"
  sudo lsof -p "$allpids" -a #-iTCP -sTCP:LISTEN
}

## *USAGE : mll [PATTERN] [EXTRA_FLAG]
## Like ls with long listing but PATTERN is case insensitive and
## matches any part of the file name
mll() {
  [[ $IS_BASH == 1 && $IS_HOME == 1 ]] && local option="--group-directories-first"
  [[ ! -z $1 && $1 != -* ]] && local pattern="*$1*"
  local ls_command
  ls_command=( ls "-l" "--color=always" "--human-readable" "--time-style=iso" "--no-group" $option )

  setoption nocaseglob
  [[ -z $pattern ]] || shift
  # Zsh does not perform file name expansion on variables and local forces expansion
  eval "${ls_command[*]} $1 $pattern"
  setoption caseglob
}

## *USAGE : mfind SEARCH_PATTERN [ROOT_DIR]
## Does NOT follow symlinks. If ROOT_DIR is not specified, the current dir will be used
mfind() {
  colecho $bldylw "Errors are redirected to /dev/null"
  if [[ $IS_GOOGLE_MAC == 1 ]]; then
    find . -iname "*$1*" 2> /dev/null
  elif [[ "$IS_UNIX" == 1 || "$IS_MSYS" == 1 ]]; then
    find -P $2 -maxdepth 9 -iname "*$1*" 2> /dev/null
  else
    find $2 -maxdepth 9 -iname "*$1*" 2> /dev/null
  fi
}

## *USAGE : h
## Triggers command line completion from history (requires fzf)
h() {
  if which fzf > /dev/null; then
    HISTTIMEFORMAT= history | sed -r 's/^[[:space:]]*[[:digit:]]+[[:space:]]*//' | fzf --no-mouse --no-hscroll
  else
    history | less
  fi
}

## *USAGE : rgrep [GREP_OPTIONS] SEARCH_REGEX
## Searches recursevely for SEARCH_REGEX in the current directory. Does not support recursive option
function rgrep() {
  colecho $bldylw "Errors are redirected to /dev/null"
  grep_cmd=( grep --recursive --with-filename --line-number --binary-files=without-match --extended-regexp --ignore-case )
  if [[ "$IS_GOOGLE_MAC" == 1 || "$IS_UNIX" == 1 || "$IS_MSYS" == 1 ]]; then
    grep_cmd=( "${grep_cmd[@]}" --color=always )
  fi
  ${grep_cmd[@]} "$@" * 2> /dev/null
}

###############################################################################################
## *USAGE : mgrep SEARCH_REGEX FILES_TO_SCAN
## Searches for SEARCH_REGEX in FILES_TO_SCAN or ALL files in current directory
mgrep() {
  colecho $bldylw "Errors are redirected to /dev/null"
  local pattern="$1"
  shift

  # zgrep for sun machines is not good !
  if [[ "$IS_GOOGLE_MAC" == 1 || "$IS_UNIX" == 1 || "$IS_MSYS" == 1 ]]; then
    grep_cmd=( zgrep --color=always --line-number --binary-files=without-match --extended-regexp --ignore-case )
  else
    grep_cmd=( grep --line-number --binary-files=without-match --extended-regexp --ignore-case )
  fi

  if [[ ${#@} == 0 ]]; then
    ${grep_cmd[@]} "$pattern" 2> /dev/null
  else
    ${grep_cmd[@]} "$pattern" "$@" 2> /dev/null
  fi
}

## *USAGE : cat_burst FILES
## Outputs FILES to stdout along with their names
cat_burst() {
  for file in "$@"; do
    if [[ -f $file ]]; then
      colecho $bldcyn "\n++++++ $file +++++++"
      cat "$file"
    else
      colecho $bldylw "$file is not a file"
    fi
  done
}

## *USAGE : to_epoch [DATE_STR]
## Gives seconds since epoch, usefull for tweaking urls parameters on some monitoring tools.
to_epoch() {
  colecho $bldylw Here are some examples
  echo '  today 13:13 pdt'
  echo '  2 days ago 00:00 pdt'
  echo '  20190615 0000 utc'
  run_cmd date '+%s' --date="$*"
}

## *USAGE : is_subdirectory ROOT_DIR CHILD_DIR
## Return 0 if CHILD_DIR is contained in ROOT_DIR, 1 otherwise
is_subdirectory() {
  local root="`echo $1 | tr '[:upper:]' '[:lower:]'`"
  local child="`echo $2 | tr '[:upper:]' '[:lower:]'`"
  [[ "$child" == "$root"* ]] && return 0
  return 1
}

## *USAGE: run_cmd [-n OUTFILE_PREFIX][-l][-r HOSTNAME] CMD [ARGUMENTS]
## Prints and runs CMD [ARGUMENTS]
## -n option will run CMD with nohup and redirect outputs to OUTFILE_PREFIX
## -l option will pipe stdout to less
## -r option will execute remotely on HOSTNAME
run_cmd() {
  local OPTIND
  while getopts ':n:r:l' opt; do
    case $opt in
      n)
        shift ; shift
        local out_file="${OPTARG}_`date +%y%m%d-%H%M%S`"
        colecho $txtcyn "Running: $@" >&2
        nohup "$@" > "${out_file}.stdout" 2> "${out_file}.stderr" &
        return $?
      ;;
      r)
        shift ; shift
        colecho $txtcyn "Running: $@" >&2
        __run_rem__ "$OPTARG" "$@"
        return $?
      ;;
      l)
        shift
        colecho $txtcyn "Running: $@" >&2
        "$@" | less
        return 0
      ;;
    esac
  done
  shift $((OPTIND-1))

  colecho $txtcyn "Running: $@" >&2
  "$@"
  return $?
}

## *USAGE: my_assert [-m MESSAGE] PREDICATE
## Asserts predicate or returns non-zero and print MESSAGE
my_assert() {
  local message=''
  if [[ "$1" == "-m" ]]; then
    message=$2
    shift ; shift
  fi
  test "$@"
  if [[ $? != 0 ]]; then
    errecho "[ASSERT FAIL] $@"
    [[ -z $message ]] || echo " => $message"
    return 1
  fi
}

## *USAGE: conf_source [-e]
## Re sources the bash customization scripts. -e allows to edit the files before sourcing.
conf_source() {
  pushd "$MY_HANDY_REPO_ROOT"
  unset BASHPROFILE_ALREADY_SOURCED
  my_assert -f install.sh || return 1
  bash ./install.sh -i
  popd

  my_assert -d $MY_ROOT_CONF_DIR || return 2
  [[ -z $1 ]] || vim -p $MY_ROOT_CONF_DIR/*.sh
  my_assert -e $HOME/.bashrc || return 3

  pushd "$HOME" > /dev/null
  source .bashrc
  popd > /dev/null
}

## *USAGE : mydiff [FILE1 FILE2]
## Diffs 2 files or stdin and pipes it to vim
mydiff() {
  local filter_cmd=cat
  [[ "$IS_WINDOWS" == 1 ]] && filter_cmd=dos2unix
  if [[ $# == 0 ]]; then
    "$filter_cmd" | vim -R -c "set syntax=diff" -
  else
    diff --unified --expand-tabs --tabsize=2 --minimal --ignore-blank-lines --ignore-all-space "$@" \
      | "$filter_cmd" \
      | vim -R -c "set syntax=diff" -
  fi  
}

## *USAGE : insert_bytes FILE OFFSET BYTES
## Inserts bytes into file at OFFSET. BYTES is a string of escape hex numbers (ex '\x0a\xdd')
insert_bytes() {
  local out_file=$1
  copy_byte_cmd=( dd conv=notrunc bs=1 seek=$2 of=$out_file )

  colecho $txtcyn "Inserting bytes using : ${copy_byte_cmd[*]}"
  printf "$3" | ${copy_byte_cmd[@]}
  hexdump -C $out_file
}

## *USAGE : get_cat
## Determines the right cat command to use if the file is compressed or not
get_cat() {
  local is_gzipped=`file $1 | grep --count --ignore-case "gzip"`
  CAT_COMMAND=cat
  [[ $is_gzipped == 1 ]] && CAT_COMMAND=zcat
}

## *USAGE : change_strings PATTERN_TO_REPLACE REPLACEMENT
## Changes any parts of the file matching PATTERN_TO_REPLACE with REPLACEMENT
change_strings() {
    local pattern="${1:-XXXXXXXXX}"
    local change="${2}"
    echo "Touching files `grep -rIEl "$pattern" *`"

    grep -rIElZ "$pattern" * 2> /dev/null | \
      grep -Zzv ".svn"                    | \
      xargs -r0 sed -r "s/$pattern/$change/g" | less

    pattern=`echo "$pattern" | sed -r 's/\\\/\\\\\\\\/g'`
    change=`echo "$change"   | sed -r 's/\\\/\\\\\\\\/g'`
    local final_cmd=( grep -rIElZ "'$pattern'" "*" "2>" /dev/null "|" grep -Zzv "'.svn'" "|" xargs -r0 sed -ri "'s/$pattern/$change/g'" )

    echo "Do it for real :"
    colecho $bldgrn "${final_cmd[@]}"
    history -s "${final_cmd[@]}"
}

## *USAGE : delete_all_dirs [-f] PATTERN_TO_DELETE
## Deletes all items (directories by default) which match PATTERN_TO_DELETE. Be careful !
delete_all_dirs() {
  local item_type=d
  if [[ $1 == '-f' ]]; then
    item_type=f
    shift
  fi
  local pattern=${1:-XXXXXXXXX}

  echo -e "You will delete files :\n`find -type $item_type -iname \"$pattern\"`"
  #find -type $item_type -iname "$pattern" -print0 2> /dev/null | xargs -r0 rm -fr
  echo "Do it for real :"
  colecho $bldgrn "  find -type $item_type -iname \"$pattern\" -print0 2> /dev/null | xargs -r0 rm -fr"
}

## *USAGE : vim_crypt CRYPT_FILE
## Decrypts CRYPT_FILE edits it with vim and crypts it again
vim_crypt() {
  local crypt_file="$1"
  local gpg_pwd=""
  # For extra security better create this in a memory backed filesystem
  local user_num=`id -u`
  local tmp_dir=`mktemp -d -p "/run/user/$user_num"`
  local tmp_file=`mktemp -u -p "$tmp_dir"`

  chmod 'go-rwx' "$tmp_dir"
  read -s -p "passphrase : " gpg_pwd

  function __cleanup__() {
    rm -rf "$tmp_dir"
  }

  # why --batch ? https://unix.stackexchange.com/questions/60213/gpg-asks-for-password-even-with-passphrase
  local -a vim_cmd=( vim -c ":file $tmp_file" -c ':set nobackup' -c ':set nowritebackup' -c ':set noswapfile' )
  local -a crypt_cmd=( gpg --symmetric --cipher-algo AES256 --batch --passphrase "$gpg_pwd" --output '-' )
  local -a decrypt_cmd=( gpg --decrypt --batch --passphrase "$gpg_pwd" )

  (
    trap __cleanup__ EXIT INT TERM
    if [[ -e "$crypt_file" ]]; then
      "${decrypt_cmd[@]}" "$crypt_file" | "${vim_cmd[@]}" -
      [[ "${PIPESTATUS[0]}" == "0" ]] && [[ -f "$tmp_file" ]] \
        && "${crypt_cmd[@]}" "$tmp_file" > "$crypt_file"
    fi  
  )
}

## *USAGE: my_vim_edit_all [PATTERN] [START_WITH]
## Opens all files matching PATTERN one at a time
## START_WITH will skip all files lexicographicaly less than it
my_vim_edit_all() {
  local -a posts=( `find . -iname "$1" | sort` )
  local start_with="$2"
  for post in "${posts[@]}"; do
    colecho $txtcyn "$post"
    [[ "$start_with" < "$post" ]] || continue
    [[ -f "$post" ]] && vim "$post"

    read -p 'continue with next [Y|n] ? ' keepon
    [[ "$keepon" == "n" ]] && return 1
  done
}

## *USAGE : pack_ssh [FILE1 FILE2]
## Packs ssh config into scripts repo
pack_ssh() {
  [[ -d "$HOME/.ssh" ]] || return 1
  local curdir=`readlink -f .`
  local tmp_dir=`mktemp -d`
  chmod 'go-rwx' "$tmp_dir" || return 2

  function __cleanup__() {
    local -a msg=( "delete" "$tmp_dir"/.ssh "$tmp_dir"/* " [y/N] : ")
    local doit=n
    read -p "${msg[*]}" doit
    [[ "$doit" == "y" ]] || return 3
    shred "$tmp_dir"/.ssh/*
    shred "$tmp_dir"/*
    rm -rf "$tmp_dir"
  }

  (
    trap __cleanup__ EXIT INT TERM
    pushd "$HOME"
    cp -rf .ssh "$tmp_dir"
    pushd "$tmp_dir/.ssh"
    colecho $txtcyn "$tmp_dir : choose files to keep and exit"
    PS1=" > " bash --noprofile --norc
    pushd "$tmp_dir"
    tar zcf ssh.tar .ssh
    gpg --symmetric --cipher-algo AES256 --output 'ssh.tar.gpg' 'ssh.tar'
    cp ssh.tar.gpg "$curdir"
  )
}

## import_patch_list ORIGING_REPO COMMIT_RANGE
## Get patches for each revision in COMMIT_RANGE and apply it to the git repo under the current directory.
import_patch_list() {
  local origin_repo_root="$1"
  shift
  local -a commit_range=( "$@" )

  [[ -d "$origin_repo_root" ]] || return 1

  pushd "$origin_repo_root"
  local -a patch_list=( `git format-patch "${commit_range[@]}"` )
  [[ ${#patch_list[@]} -gt 0 ]] || return 2
  popd

  echo "
  Apply patch_list ?
  ${patch_list[@]}"
  read -p "y/n ? " go_for_it
  [[ "$go_for_it" == 'y' ]] || return 6

  for patch in "${patch_list[@]}"; do
    colecho $txtcyn "Processing patch : $patch"
    mv "$origin_repo_root/$patch" . || return 3
    if ! git apply --check --verbose "$patch"; then
      errecho "Failed, try patching manually : "
      echo "patch --merge -p1 -u -i '$patch'"
      return 4
    fi
    git am --ignore-whitespace "$patch" || return 5
  done
}

## Prints some nice bash shortcuts that I tend to forget ...
cheatsheat() {
  echo -e "### EDITING"
  echo -e "${bldcyn}Ctrl-a/Ctrl-e${txtrst} Go to the start and end of the line"
  echo -e "${bldcyn}Ctrl-k${txtrst}        Forward delete the whole line"
  echo -e "${bldcyn}Ctrl-s/Ctrl-q${txtrst} Disables/Enables keyboard input"
  echo -e "${bldcyn}Alt-f/Alt-b${txtrst}   Go forward/backward on words"
  echo -e "${bldcyn}Alt-d${txtrst}         Forward delete word"

  echo -e "\n### COMPLETION"
  echo -e "${bldcyn}Alt-Shift-4${txtrst}   Complete variables"
  echo -e "${bldcyn}Alt-/${txtrst}         Complete file names"
  echo -e "${bldcyn}Alt-Shift-{${txtrst}   Complete file names for brace expansion"

  echo -e "\n### JOBS"
  echo -e "${bldcyn}!*${txtrst}            Last command arguments"
  echo -e "${bldcyn}Ctrl-z${txtrst}        Suspend, ${bldcyn}<command>&${txtrst} to launch asynchronously"
  echo -e "${bldcyn}fg/bg${txtrst}         Resume on foreground/background"

  echo -e "\n### COMMANDS"
  echo -e "${bldcyn}type NAME${txtrst}     Tell if NAME is an alias/function/exe"
}

# Color manual pages
# See https://wiki.archlinux.org/index.php/Man_page#Using_less_.28Recommended.29
man() {
  env \
   LESS_TERMCAP_mb=$(printf $bldred) \
   LESS_TERMCAP_md=$(printf $bldred) \
   LESS_TERMCAP_me=$(printf $txtrst) \
   LESS_TERMCAP_se=$(printf $txtrst) \
   LESS_TERMCAP_so=$(printf $bkgwht$bldblu) \
   LESS_TERMCAP_ue=$(printf $txtrst) \
   LESS_TERMCAP_us=$(printf $bldgrn) \
   GROFF_NO_SGR=1 \
  man "$@"
}

## *USAGE: is_too_old FILEPATH MIN_COUNT
## Exits withour error if FILEPATH desgins a file which has been modified in the last MIN_COUNT minutes.
is_recent_enough() {
  find "$1" -mmin "-$2" -type f 2> /dev/null \
    | grep -E '.*' &> /dev/null
}

## *USAGE: to_space_separated < STDIN
## Transforms a new line separated list to a space separated list.
## Convienient to use with here-docs.
to_space_separated() {
  paste -s -d" " | sed -r 's/^[[:space:]]+|[[:space:]]+$//g'
}

## *USAGE: helpme [-f] [COMMAND_REGEX]
## Creates the help text you are reading :-D
## The __-f__ flag will force the help file generation in case the scripts have changed
helpme() {
  local file_filter="sh|awk|ps1"
  local -a find_options=( "-regextype" "posix-extended" "-type" "f" "-iregex" ".*($file_filter)\$" )
  local conffiles="`find $MY_ROOT_CONF_DIR $MY_ROOT_SCRIPT "${find_options[@]}" 2> /dev/null`"
  run_cmd find $MY_ROOT_CONF_DIR $MY_ROOT_SCRIPT "${find_options[@]}" 2> /dev/null
  split_words "$conffiles"

  if [[ ! -f $TMP_HELP_FILE || $1 == "-f" ]]; then
    set +o noclobber
    echo > $TMP_HELP_FILE
    for item in ${SPLIT_WORDS_RESULT[*]}; do
      local last_dir=$(basename "`dirname "$item"`")
      local name=${item##*/}
      if regexmatch $name "($file_filter)$"; then
        gawk -f $AWK_COLOR_SCRIPT -f $AWK_MAN_FORMAT -v "FILE_TITLE=$last_dir/$name" $item  >> $TMP_HELP_FILE
        echo "Processing $item ..."
      fi
    done
  fi

  local pattern="-p^"
  [[ $# -gt 0 ]] && [[ ! -z $2 || $1 != "-f" ]] && pattern="-p${2:-$1}"
  less $pattern $TMP_HELP_FILE
}

